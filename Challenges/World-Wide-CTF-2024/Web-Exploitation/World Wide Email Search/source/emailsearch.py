import sqlite3
from unidecode import unidecode
from random import choice
from jinja2 import Environment, PackageLoader, select_autoescape
from flask import Flask, render_template, request

from email_validator import validate_email, EmailNotValidError


# Template engine
env = Environment(
    loader=PackageLoader("emailsearch"),
    autoescape=select_autoescape()
)

# Database
conn = sqlite3.connect('file::memory:?cache=shared', check_same_thread=False)

# Webservice
app = Flask(__name__)

# Return rendered template
def create_http_response(render_words):
    template = env.get_template("search.html")
    return template.render(render_words=render_words).encode()


@app.route("/")
def search_email():
    render_words = []

    # Get email query
    email = request.args.get("email", "").strip()
    if email == '':
    	return create_http_response(render_words)

    try:
        # Remove quotes and backslashes
        email = email.replace("'", "").replace("\"", "").replace("\\", "")

        # Validate email
        try:
          emailinfo = validate_email(email, check_deliverability=False)
          email = emailinfo.normalized

        except EmailNotValidError as e:
        	# print(str(e))
        	render_words.append("[X] Invalid email address")
        	return create_http_response(render_words)

        # Unicode normalize
        email = unidecode(email)

        # Search email
        render_words.append(f"[?] Searching messages for email {email}...")

        # Execute query
        cur = conn.cursor()
        query = "SELECT message from messages where email = '" + email + "'"
        cur.execute(query)

        # Get result
        ret = cur.fetchone()
        if ret is not None:
            ret = ret[0]
            render_words.append(f"[Y] Found message for email: {ret}")
            return create_http_response(render_words)
        else:
            render_words.append(f"[X] No message found for email {email}")
            return create_http_response(render_words)

    except Exception as e:
        render_words.append(f"[X] Error: {str(e)}")
        return create_http_response(render_words)


def main():
    cur = conn.cursor()

    # Create tables for messages and the flag
    cur.execute("""
        CREATE TABLE flagz (
            id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
            flag TEXT
        );
    """)
    cur.execute("""
        CREATE TABLE messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
            message TEXT,
            email TEXT
        );
    """)

    # Flag
    cur.execute("INSERT INTO flagz (flag) VALUES ('wwf{1nT3rN4ti0n4l_3Ma1lInj3cT9on}');")
    conn.commit()

    # Insert messages for emails
    emails = [
        "admin@wwctf.com",
        "user@wwctf.com",
        "foo@bar.com"
    ]
    messages = [
        "Welcome back admin!",
        "Hello user",
        "Foobar?!"
    ]

    for email, message in zip(emails, messages):
        cur.execute("INSERT INTO messages (message, email) VALUES (?, ?);", (message, email))
    conn.commit()

    app.run('0.0.0.0', 2000)

if __name__ == "__main__":
    main()
